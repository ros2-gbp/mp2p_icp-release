# -----------------------------------------------------------------------------
# Pipeline definition file for sm2mm (simplemap-to-metricmap)
#
# See: https://github.com/MOLAorg/mp2p_icp/tree/develop/apps/sm2mm
#
# Explanation of this particular pipeline:
#  - Generators: empty, so the default generator is used (everything in one
#                layer named 'raw' with all points).
#  - Filters: Deskew using IMU, remove close points.
#  - Final filters: intensity normalization, MLS filtering.
# -----------------------------------------------------------------------------

# --------------------------------------------------------
# 1) Generator (observation -> local frame metric maps)
# --------------------------------------------------------
#generators:
#  - class_name: mp2p_icp_filters::Generator
#    params: ~

# --------------------------------------------------------
# 2) Per local frame filtering
# --------------------------------------------------------
filters:
  - class_name: mp2p_icp_filters::FilterAdjustTimestamps
    params:
      pointcloud_layer: "raw"
      silently_ignore_no_timestamps: false
      method: "TimestampAdjustMethod::MiddleIsZero"

  - class_name: mp2p_icp_filters::FilterDeskew
    params:
      input_pointcloud_layer: "raw"
      output_pointcloud_layer: "deskewed"
      method: MotionCompensationMethod::IMU
      silently_ignore_no_timestamps: false

      output_layer_class: "mrpt::maps::CGenericPointsMap" # Keep all channels: intensity, ring, ...

      # These (vx,...,wz) are variable names that must be defined via the
      # mp2p_icp::Parameterizable API to update them dynamically.
      twist: [vx, vy, vz, wx, wy, wz]

      # IMPORTANT: In the context of sm2mm, de-skew happens with points already in global coordinates
      # so we need the robot pose to correct points:
      points_already_global: true
      robot_pose:
        [robot_x, robot_y, robot_z, robot_yaw, robot_pitch, robot_roll]

  - class_name: mp2p_icp_filters::FilterByRange
    params:
      input_pointcloud_layer: "deskewed"
      output_layer_outside: "filtered"
      range_min: 0.0
      range_max: 3.0
      metric_l_infinity: true # Faster
      # Measure distances from the moving robot pose:
      center: [robot_x, robot_y, robot_z]

  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      # one or more layers to remove
      pointcloud_layer_to_remove: ["raw", "deskewed"]

# -------------------------------------------------------------------
# 3) Final, overall filter pipeline to apply to the whole metric map
# -------------------------------------------------------------------
final_filters:
  # ----------------------------------------------------------------------
  # Configuration for the Moving Least Squares (MLS) Filter
  # ----------------------------------------------------------------------
  - class_name: mp2p_icp_filters::FilterMLS
    params:
      # The layer containing the point cloud used to compute the MLS surface.
      # This is the 'source' cloud for the surface fitting.
      input_pointcloud_layer: "filtered"

      # The layer where the smoothed/projected points and their normals will be
      # stored. If it doesn't exist, it will be created.
      output_pointcloud_layer: "mls"

      # The class name for output layer if it does not exist and needs to be
      # created. Empty means same class than input.
      output_layer_class: "mrpt::maps::CGenericPointsMap"

      # ====================================================================
      # MLS Core Parameters
      # ====================================================================

      # Search radius (in meters) for finding neighbors around each query point.
      # A larger radius results in a smoother but potentially less detailed surface.
      search_radius: 0.10

      # Order of the polynomial to fit to the local neighborhood.
      # 1: Planar fit (fastest, basically a weighted PCA for normals).
      # 2: Quadratic fit (standard for curvature/better smoothing).
      # 3+: Higher order (can lead to oscillations/overfitting).
      polynomial_order: 2

      # Minimum number of neighbors required to successfully compute a fit.
      # Should be at least 3 for a basic plane (order 1), and more for order 2+.
      min_neighbors_for_fit: 10

      # ====================================================================
      # Smoothing / Projection Method
      # ====================================================================

      # Method for projecting points onto the fitted polynomial surface.
      # SIMPLE: Project point along the normal direction to the polynomial at
      #         the projected (u,v) location. (Fast and robust).
      projection_method: FilterMLS::ProjectionMethod::SIMPLE

      # Method for determining which points to smooth/project.
      # NONE: Smooth the 'input_pointcloud_layer' itself (standard smoothing).
      # DISTINCT_CLOUD: Build the surface from 'input_pointcloud_layer', but
      #                 project the points from 'distinct_cloud_layer' onto it
      #                 (used for upsampling or projection).
      upsampling_method: FilterMLS::UpsamplingMethod::NONE

      # Required only if upsampling_method is DISTINCT_CLOUD.
      # The points in this layer are the ones that will be projected onto the
      # surface computed from 'input_pointcloud_layer'.
      # distinct_cloud_layer: "sparse_scan"

      # ====================================================================
      # Parallelization
      # ====================================================================

      # If TBB is enabled, this is the grain size for parallel execution.
      # Smaller values increase parallelism overhead; larger values may leave
      # cores idle. Default (1024UL) is typically good.
      parallelization_grain_size: 1024
