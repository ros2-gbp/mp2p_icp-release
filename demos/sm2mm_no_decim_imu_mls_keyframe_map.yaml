# ---------------------------------------------------------------------------------------------
# Pipeline definition file for sm2mm (simplemap-to-metricmap)
#
# See: https://github.com/MOLAorg/mp2p_icp/tree/develop/apps/sm2mm
#
# Explanation of this particular pipeline:
#  - Generators: Default generator creating 'raw', another just creating
#                an empty layer "localmap" for GICP MOLA-LIO usage.
#  - Filters per observation: Deskew using IMU, remove close points.
#  - Final filters at end: intensity normalization, MLS filtering, insert into "localmap"
# ---------------------------------------------------------------------------------------------

# --------------------------------------------------------
# 1) Generator (observation -> local frame metric maps)
# --------------------------------------------------------
generators:
  # This one will convert all incoming lidar scan observations into pointclouds in layer "raw"
  - class_name: mp2p_icp_filters::Generator
    params:
      name: "generator_default"

  # This one will just create the layer "localmap", expected by the GICP LIO algorithm for localization
  - class_name: mp2p_icp_filters::Generator
    params:
      name: "generator_localmap"
      target_layer: "localmap"
      throw_on_unhandled_observation_class: true
      process_class_names_regex: "" # None, do not insert directly, but in the final_filters stage.
      #process_sensor_labels_regex: '.*'

      metric_map_definition:
        # Any class derived from mrpt::maps::CMetricMap https://docs.mrpt.org/reference/latest/group_mrpt_maps_grp.html
        class: mola::KeyframePointCloudMap
        plugin: "libmola_metric_maps.so" # Import additional custom user-defined map classes (search in LD_LIBRARY_PATH)
        creationOpts:
          max_search_keyframes: 3
          k_correspondences_for_cov: 20
        insertOpts:
          remove_frames_farther_than: 0 # [m]
        likelihoodOpts: ~ # none required
        renderOpts:
          color.A: 0.25 # [0,1] Use this alpha value for points, RGB from colormap
          colormap: "cmHOT" # cmJET, cmHOT, cmGRAYSCALE
          recolorByPointField: "z" # x,y,z,ring, intensity, ambient, etc.
          max_points_per_kf: 100000 # Max number of points to render per keyframe
          max_overall_points: 100000 # Max number of points to render overall (e.g. to avoid FoxGlove WS overflow)
          #point_size: 1.0  # superseded by visualization.local_map_point_size when run inside MOLA-LIO

# --------------------------------------------------------
# 2) Per local frame filtering
# --------------------------------------------------------
filters:
  - class_name: mp2p_icp_filters::FilterAdjustTimestamps
    params:
      pointcloud_layer: "raw"
      silently_ignore_no_timestamps: false
      method: "TimestampAdjustMethod::MiddleIsZero"

  - class_name: mp2p_icp_filters::FilterDeskew
    params:
      input_pointcloud_layer: "raw"
      output_pointcloud_layer: "deskewed"
      method: MotionCompensationMethod::IMU
      silently_ignore_no_timestamps: false

      output_layer_class: "mrpt::maps::CGenericPointsMap" # Keep all channels: intensity, ring, ...

      # These (vx,...,wz) are variable names that must be defined via the
      # mp2p_icp::Parameterizable API to update them dynamically.
      twist: [vx, vy, vz, wx, wy, wz]

      # IMPORTANT: In the context of sm2mm, de-skew happens with points already in global coordinates
      # so we need the robot pose to correct points:
      points_already_global: true
      robot_pose:
        [robot_x, robot_y, robot_z, robot_yaw, robot_pitch, robot_roll]

  - class_name: mp2p_icp_filters::FilterByRange
    params:
      input_pointcloud_layer: "deskewed"
      output_layer_outside: "filtered"
      range_min: 0.0
      range_max: 3.0
      metric_l_infinity: true # Faster
      # Measure distances from the moving robot pose:
      center: [robot_x, robot_y, robot_z]

  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      # one or more layers to remove
      pointcloud_layer_to_remove: ["raw", "deskewed"]

# -------------------------------------------------------------------
# 3) Final, overall filter pipeline to apply to the whole metric map
# -------------------------------------------------------------------
final_filters:
  # ----------------------------------------------------------------------
  # Configuration for the Moving Least Squares (MLS) Filter
  # ----------------------------------------------------------------------
  - class_name: mp2p_icp_filters::FilterMLS
    params:
      # The layer containing the point cloud used to compute the MLS surface.
      # This is the 'source' cloud for the surface fitting.
      input_pointcloud_layer: "filtered"

      # The layer where the smoothed/projected points and their normals will be
      # stored. If it doesn't exist, it will be created.
      output_pointcloud_layer: "mls"

      # The class name for output layer if it does not exist and needs to be
      # created. Empty means same class than input.
      output_layer_class: "mrpt::maps::CGenericPointsMap"

      # ====================================================================
      # MLS Core Parameters
      # ====================================================================

      # Search radius (in meters) for finding neighbors around each query point.
      # A larger radius results in a smoother but potentially less detailed surface.
      search_radius: 0.10

      # Order of the polynomial to fit to the local neighborhood.
      # 1: Planar fit (fastest, basically a weighted PCA for normals).
      # 2: Quadratic fit (standard for curvature/better smoothing).
      # 3+: Higher order (can lead to oscillations/overfitting).
      polynomial_order: 2

      # Minimum number of neighbors required to successfully compute a fit.
      # Should be at least 3 for a basic plane (order 1), and more for order 2+.
      min_neighbors_for_fit: 10

      # ====================================================================
      # Smoothing / Projection Method
      # ====================================================================

      # Method for projecting points onto the fitted polynomial surface.
      # SIMPLE: Project point along the normal direction to the polynomial at
      #         the projected (u,v) location. (Fast and robust).
      projection_method: FilterMLS::ProjectionMethod::SIMPLE

      # Method for determining which points to smooth/project.
      # NONE: Smooth the 'input_pointcloud_layer' itself (standard smoothing).
      # DISTINCT_CLOUD: Build the surface from 'input_pointcloud_layer', but
      #                 project the points from 'distinct_cloud_layer' onto it
      #                 (used for upsampling or projection).
      upsampling_method: FilterMLS::UpsamplingMethod::NONE

      # Required only if upsampling_method is DISTINCT_CLOUD.
      # The points in this layer are the ones that will be projected onto the
      # surface computed from 'input_pointcloud_layer'.
      # distinct_cloud_layer: "sparse_scan"

      # ====================================================================
      # Parallelization
      # ====================================================================

      # If TBB is enabled, this is the grain size for parallel execution.
      # Smaller values increase parallelism overhead; larger values may leave
      # cores idle. Default (1024UL) is typically good.
      parallelization_grain_size: 1024

  # Specific map for localization with the GICP pipeline
  - class_name: mp2p_icp_filters::FilterMerge
    params:
      input_pointcloud_layer: "mls"
      target_layer: "localmap"

  - class_name: mp2p_icp_filters::FilterDeleteLayer
    params:
      # one or more layers to remove
      pointcloud_layer_to_remove: ["filtered", "mls"]
